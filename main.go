package main

import (
	"fmt"
	"bytes"
	"strings"
	"html/template"
	"regexp"
	"path/filepath"
	"flag"
	"bufio"
	. "github.com/dave/jennifer/jen"
	"os"
)

/*
examples of structs that would be generated by this code, depending on the input format:

type FormContent struct {
	Title string
	Password string
	HeaderImage string
	Description string
}

type FormAnswer struct {
	Name string `json:"name"`
	Address string `json:"address"`
	StickerSheetAmount int `json:"sticker-sheet-amount"
	AccessToken string `json:"access-token"`
}


input format expected (whitespace around equals sign is irrelevant):

form-title          = Merveilles Stickers
form-desc           = Hey mervs, welcome to this form! Fill in the inputs below and then press submit!
form-password       = hihi-stickertown
input[Name]         = First and last name
textarea[Address]   = your postal address
number[Sticker sheet amount]#amount                 = min=1, max=5, value=1
input[The rabbit boat but backwards]#access-token   = you know it.
radio[Size]                                         = Small, Medium, Large
*/

func jsonTag (value string) map[string]string {
	return map[string]string{"json":value}
}

type genValue struct {
	element string
	title string
	value string
	key string
	options map[string]string
}

type Theme struct {
	background, title, body string
}

type TemplateData struct {
	Background, TitleColor, Body, Content template.HTML
	Title string
}

func parseFormat(format string) []genValue {
	pattern := regexp.MustCompile(`(form-\w+)|(\S*)(\[.*\])([#]\S+)?`)
	scanner := bufio.NewScanner(strings.NewReader(format))
	var genList []genValue
	for scanner.Scan() {
		line := scanner.Text()
		splitterIndex := strings.Index(line, "=")
		left := strings.TrimSpace(line[0:splitterIndex])

		var v genValue 
		v.value = strings.TrimSpace(line[splitterIndex+1:])
		matches := pattern.FindStringSubmatch(left)
		if len(matches) > 1 {
			v.element = strings.TrimSpace(matches[1])
		}
		if len(matches) > 2 && v.element == "" {
			v.element = strings.TrimSpace(matches[2])
		}
		if len(matches) > 3 && matches[3] != "" {
			// get everything except [thing] brackets
			v.title = matches[3][1:len(matches[3])-1]
		}
		if len(matches) > 4 && matches[4] != "" {
			// remove initial #
			v.key = strings.TrimSpace(matches[4][1:])
		}
		genList = append(genList, v)
	}
	return genList
}

const htmlTemplate = `<!DOCTYPE html>
<html>
	<head>
		<title>{{ .Title }}</title>
		<style>
		html {
			background: {{ .Background }};
			color: {{ .Body }};
			padding-left: 2rem;
			padding-right: 2rem;
			padding-top: 1rem;
		}
		h1 {
			color: {{ .TitleColor }};
		}
		* {
			padding: 0;
			margin-bottom: 0.5rem;
		}
		div {
			display: grid;
			max-width: 600px;
			align-items: center;
		}
		</style>
	</head>
	<body>
	{{ .Content }}
	</body>
</html>`

func formatKeyAndTitle(v genValue) (string, string) {
	key := strings.ToLower(v.title)
	title := strings.ReplaceAll(strings.Title(v.title), " ", "")
	if len(v.key) > 0 {
		key = v.key
		title = strings.ReplaceAll(strings.Title(strings.ReplaceAll(v.key, "-", " ")), " ", "")
	}
	return key, title
}

const formPackageName = "myform"
func main() {
	var htmlList []string
	var theme Theme
	var setPassword string
	var pageTitle string
	var formatFp string
	flag.StringVar(&formatFp, "input", "", "a file containing the form format to generate a form server using")
	flag.Parse()
	if formatFp == "" {
		fmt.Println("must pass --input <file containing form format>")
		os.Exit(0)
	}
	b, err := os.ReadFile(formatFp)
	if err != nil {
		fmt.Println("issue when reading format file", err)
	}
	format := string(b)

	values := parseFormat(format)

	f := NewFile(formPackageName)
	var contentBits []Code
	var answer []Code
	var resParse []Code
	for _, input := range values {
		switch input.element {
		case "form-title":
			contentBits = append(contentBits, Id("Title").String())
			htmlList = append(htmlList, fmt.Sprintf(`<h1>%s</h1>`, input.value))
			pageTitle = input.value
		case "form-desc":
			contentBits = append(contentBits, Id("Description").String())
			htmlList = append(htmlList, fmt.Sprintf(`<p>%s</p>`, input.value))
		case "form-image":
			contentBits = append(contentBits, Id("Image").String())
			htmlList = append(htmlList, fmt.Sprintf(`<img src="%s">`, input.value))
		case "form-password":
			setPassword = input.value
			// information used for basic auth, limiting access to the form
			contentBits = append(contentBits, Id("Password").String())
		case "form-bg":
			fmt.Println("bg")
			theme.background = input.value
			fmt.Println("ttl")
		case "form-titlecolor":
			theme.title = input.value
		case "form-fg":
			fmt.Println("bdy")
			theme.body = input.value
		}
	}

	htmlList = append(htmlList, `<form action="/" method="post">`)
	for _, input := range values {
		switch input.element {
		case "textarea":
			key, title := formatKeyAndTitle(input)
			htmlList = append(htmlList, "<div>")
			htmlList = append(htmlList, fmt.Sprintf(`<label for="%s">%s</label>`, key, title))
			el := fmt.Sprintf(`<textarea placeholder="%s" name="%s"></textarea>`, input.value, key)
			htmlList = append(htmlList, el)
			htmlList = append(htmlList, "</div>")
			answer = append(answer, Id(title).String().Tag(jsonTag(key)))
			resParse = append(resParse, Id("answer").Dot(title).Op("=").Id("req").Dot("PostFormValue").Call(Lit(key)))
		case "input":
			key, title := formatKeyAndTitle(input)
			htmlList = append(htmlList, "<div>")
			htmlList = append(htmlList, fmt.Sprintf(`<label for="%s">%s</label>`, key, input.title))
			el := fmt.Sprintf(`<input type="text" placeholder="%s" name="%s"/>`, input.value, key)
			htmlList = append(htmlList, el)
			htmlList = append(htmlList, "</div>")
			answer = append(answer, Id(title).String().Tag(jsonTag(key)))
			resParse = append(resParse, Id("answer").Dot(title).Op("=").Id("req").Dot("PostFormValue").Call(Lit(key)))
		case "number":
			optionsList := strings.Split(input.value, ",")
			var options string
			htmlList = append(htmlList, "<div>")
			for _, optionPair := range optionsList {
				optionPair = strings.TrimSpace(optionPair)
				parts := strings.Split(optionPair, "=")
				options += fmt.Sprintf(`%s="%s" `,parts[0], parts[1])
			}
			key, title := formatKeyAndTitle(input)
			htmlList = append(htmlList, fmt.Sprintf(`<label for="%s">%s</label>`, key, title))
			el := fmt.Sprintf(`<input type="number" %s name="%s"/>`, options, key)
			htmlList = append(htmlList, el)
			htmlList = append(htmlList, "</div>")
			answer = append(answer, Id(title).String().Tag(jsonTag(key)))
			resParse = append(resParse, Id("answer").Dot(title).Op("=").Id("req").Dot("PostFormValue").Call(Lit(key)))
		case "range":
			optionsList := strings.Split(input.value, ",")
			var options string
			htmlList = append(htmlList, "<div>")
			for _, optionPair := range optionsList {
				optionPair = strings.TrimSpace(optionPair)
				parts := strings.Split(optionPair, "=")
				options += fmt.Sprintf(`%s="%s" `,parts[0], parts[1])
			}
			key, title := formatKeyAndTitle(input)
			htmlList = append(htmlList, fmt.Sprintf(`<label for="%s">%s</label>`, key, title))
			el := fmt.Sprintf(`<input type="range" %s name="%s"/>`, options, key)
			htmlList = append(htmlList, el)
			htmlList = append(htmlList, "</div>")
			answer = append(answer, Id(title).String().Tag(jsonTag(key)))
			resParse = append(resParse, Id("answer").Dot(title).Op("=").Id("req").Dot("PostFormValue").Call(Lit(key)))
		case "radio":
			options := strings.Split(input.value, ",")
			key, title := formatKeyAndTitle(input)

			htmlList = append(htmlList, "<div>")
			htmlList = append(htmlList, fmt.Sprintf(`<span>%s</span>`, input.title))
			for i, val := range options {
				options[i] = strings.TrimSpace(val)
				radioValue := strings.ToLower(options[i])
				radioId := fmt.Sprintf(`%s-option-%s`, key, radioValue)
				htmlList = append(htmlList, "<span>")
				el := fmt.Sprintf(`<input type="radio" id="%s" value="%s" name="%s"/>`, radioId, radioValue, key)
				htmlList = append(htmlList, el)
				htmlList = append(htmlList, fmt.Sprintf(`<label for="%s">%s</label>`, radioId, options[i]))
				htmlList = append(htmlList, "</span>")

			}
			htmlList = append(htmlList, "</div>")
			answer = append(answer, Id(title).String().Tag(jsonTag(key)))
			resParse = append(resParse, Id("answer").Dot(title).Op("=").Id("req").Dot("PostFormValue").Call(Lit(key)))
		}
	}

	htmlList = append(htmlList, `<div><button type="submit">Submit</button></div>`)
	htmlList = append(htmlList, "</form>")

	// set BasicPassword const
	f.Const().Id("BasicPassword").Op("=").Lit(setPassword)
	// generate FormContent struct
	f.Type().Id("FormContent").Struct(contentBits...)
	// generate FormAnswer struct
	f.Type().Id("FormAnswer").Struct(answer...)

	// generate FormAnswer.ParsePost() 
	f.Func().Params(
		Id("answer").Id("*FormAnswer"),
	).Id("ParsePost").Params(
		Id("req").Op("*").Qual("net/http", "Request"),
	).Block(resParse...)

	fmt.Printf("%#v", f)

	// make sure the package folder will exist
	err = os.MkdirAll(formPackageName, 0777)
	if err != nil {
		fmt.Println("err mkdirall", err)
	}
	// write the generated form model to disk
	generatedCode := fmt.Sprintf("%#v", f)
	genCodeErr := os.WriteFile(filepath.Join(formPackageName, "generated-form-model.go"), []byte(generatedCode), 0777)
	if genCodeErr != nil {
		fmt.Println(genCodeErr)
	}
	var data TemplateData
	data.Content = template.HTML(strings.Join(htmlList, "\n"))
	fmt.Println(theme)
	if theme.background != "" {
		data.Background = template.HTML(theme.background)
	}
	if theme.body != "" {
		data.Body = template.HTML(theme.body)
	}
	if theme.title != "" {
		data.TitleColor = template.HTML(theme.title)
	}
	data.Title = pageTitle
	// write the page htmlList
	var buf bytes.Buffer
	t := template.Must(template.New("").Parse(htmlTemplate))
	t.Execute(&buf, data)
	indexWriteErr := os.WriteFile("index-template.html", buf.Bytes(), 0777)
	if indexWriteErr != nil {
		fmt.Println(indexWriteErr)
	}
}
